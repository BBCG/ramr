#       scale_x_continuous(name="position") +
#       scale_y_continuous(name="beta value", limits=c(-0, 1), breaks=c(0, 0.25, 0.5, 0.75, 1)) +
#       scale_color_discrete(name="samples", limits=colorify) +
#       scale_alpha_continuous(guide="none") +
#       theme(legend.text=element_text(size=8), #legend.position="none", legend.title=element_blank(),
#             axis.text.x=element_text(size=8, angle=0), #, color=.data.cpgs.colors),
#             axis.text.y=element_text(size=8)) +
#       ggtitle( ifelse( !is.null(title), title, as.character(reduce(plot.ranges)) ) )
#
#     print(gene.plot)
#   }
# }
library(GenomicRanges)
library(data.table)
library(doParallel)
library(matrixStats)
library(ggplot2)
library(gridExtra)
library(EnvStats)
library(logitnorm)
# load
project  <- "GSE51032"
proj.dir <- paste0("/Home/siv22/oni062/work/scripts/ramr/data/", project, "/")
load(paste0(proj.dir, project, ".data.Rdata"))
load("/Home/siv22/oni062/work/scripts/tcga/data/tempfiles/to.remove.RData")
# clean
geo.ranges <- geo.ranges[!(names(geo.ranges) %in% to.remove)]
geo.ranges <- geo.ranges[!(seqnames(geo.ranges) %in% c("chrX","chrY"))]
# process, but don't forget to copy-paste functions first...
system.time(ramr <- getRAMR(geo.ranges, sample.ids, ramr.method="beta", qval.cutoff=1e-3, min.cpgs=7, merge.window=1000)) # in principle, wbeta at 1e-5 gives appropriate results
ramr <- ramr[order(ramr$pval)]
ramr
sort(table(ramr$sample))
do.call("grid.arrange", c(plotRAMR(geo.ranges, sample.ids, ramr[1:6]), ncol=2))
# info table
library(stringr)
library(dplyr)
info.list  <- lapply(sample.info, function(x){
match.table <- str_match(x$characteristics_ch1, pattern="(.*?): (.*)")
result <- match.table[,3]
names(result) <- match.table[,2]
return(result)
})
info.table <- data.frame(do.call(bind_rows, info.list), row.names=names(info.list), stringsAsFactors=FALSE, check.names=FALSE)
info.table$age <- as.numeric(as.character(info.table$age))
info.table <- cbind( info.table, nramr=as.numeric(table(ramr$sample)[rownames(info.table)]) )
info.table[is.na(info.table$nramr), "nramr"] <- 0
info.table$hasramr <- as.factor(info.table$nramr>0)
info.table$cancer  <- as.factor(!is.na(info.table$`cancer type (icd-10)`))
info.table$ctype   <- as.factor(sapply(info.table$`cancer type (icd-10)`, function (icd10) {
case_when(
grepl("C[12].", icd10) ~ "colorectal",
icd10 == "C50"         ~ "breast",
is.na(icd10)           ~ NA_character_,
TRUE                   ~ "other"
)
}))
# gene names
load("/Home/siv22/oni062/work/scripts/ramr/data/GRCh37.p13.2019.12.12.Rdata")
system.time(ramr$genes <- sapply(split(ramr,1:length(ramr)),
function(x){ suppressWarnings( paste0( unique(grch37.ranges[queryHits(findOverlaps(grch37.ranges,x,maxgap=5000,ignore.strand=TRUE))]$`Gene name`) ,collapse=", ") ) }))
info.table[ramr[ramr$genes=="RALGAPA2"]$sample,]
plotRAMR(geo.ranges, sample.ids, ramr[ramr$genes=="RALGAPA2"])
info.table[ramr[grep("CHFR",ramr$genes)]$sample,]
plotRAMR(geo.ranges, sample.ids, ramr[grep("CHFR",ramr$genes)])
info.table[ramr[grep("BRCA1",ramr$genes)]$sample,]
plotRAMR(geo.ranges, sample.ids, ramr[grep("BRCA1",ramr$genes)][1])
##### GSE51032 specific stuff:
## More up, but those are CpG-islands, not surprising
# up versus down
length(ramr[ramr$dbeta>0])
length(ramr[ramr$dbeta<0])
# low/high assuming normal distribution
library(car)
qqPlot(table(ramr$sample))
table.q3  <- quantile(info.table$nramr)[4]
table.iqr <- IQR(table(ramr$sample))
highRAMRcases <- rownames(info.table)[which(info.table$nramr > table.q3+1.5*table.iqr)]
lowRAMRcases  <- setdiff(sample.ids,highRAMRcases)
info.table[highRAMRcases,]
ramr[ramr$sample %in% lowRAMRcases]
info.table[ramr[grep("MGMT",ramr$genes)]$sample,]
plotRAMR(geo.ranges, sample.ids, ramr[grep("MGMT",ramr$genes)])
info.table[ramr[grep("MSH",ramr$genes)]$sample,]
info.table[ramr[grep("MSH2",ramr$genes)]$sample,]
info.table[ramr[grep("MSH6",ramr$genes)]$sample,]
grep("MSH",ramr$genes)
grep("MSH",ramr$genes, value=T)
load("/Home/siv22/oni062/work/scripts/ramr/data/GSE51032/tcga.coad.Rdata")
tcga.coad.ramr.hg19
grep("MSH",tcga.coad.ramr.hg19$genes, value=T)
grep("MGMT",tcga.coad.ramr.hg19$genes, value=T)
grep("MGMT",grch37.ranges$`Gene name`, value=T)
grep("MGMT",grch37.ranges$`Gene name`)
grch37.ranges[grep("MGMT",grch37.ranges$`Gene name`)]
grch37.ranges[grep("MSH2",grch37.ranges$`Gene name`)]
grch37.ranges[grep("MSH6",grch37.ranges$`Gene name`)]
plotRAMR(geo.ranges, sample.ids, grch37.ranges[grep("MSH6",grch37.ranges$`Gene name`)])
plotRAMR(geo.ranges, sample.ids, grch37.ranges[grep("MGMT",grch37.ranges$`Gene name`)])
plotRAMR(geo.ranges, sample.ids, grch37.ranges[grep("MSH2",grch37.ranges$`Gene name`)])
tcga.coad.ramr.hg19[grep("MGMT",grch37.ranges$`Gene name`)]
tcga.coad.ranges
colnames(tcga.coad.ranges)
colnames(mcols(tcga.coad.ranges))
plotRAMR(tcga.coad.ranges, colnames(mcols(tcga.coad.ranges))[-1], grch37.ranges[grep("MGMT",grch37.ranges$`Gene name`)])
grch37.ranges[grep("MGMT",grch37.ranges$`Gene name`)]
getRAMR <- function (data.ranges,
data.samples,
ramr.method="IQR",
iqr.cutoff=5,
pval.cutoff=5e-2,
qval.cutoff=NULL,
merge.window=300,
min.cpgs=7,
min.width=NULL,
exclude.range=NULL, #c(0.3,0.7)
cores=max(1,detectCores()-1),
...)
{
if (class(data.ranges)!="GRanges")
stop("'data.ranges' must be be a GRanges object")
if (!all(data.samples %in% colnames(mcols(data.ranges))))
stop("'data.ranges' metadata must include 'data.samples'")
if (length(data.samples)<3)
stop("at least three 'data.samples' must be provided")
#####################################################################################
getPValues.beta <- function(data.chunk, ...){
chunk.filt  <- apply(data.chunk, 1, function(x){
x.median    <- median(x, na.rm=TRUE)
x[is.na(x)] <- x.median
# x.pvals <- tryCatch(
#   {
#     beta.fit <- suppressWarnings( EnvStats::ebeta(as.numeric(x), ...) )
#     pvals    <- pbeta(x, beta.fit$parameters[1], beta.fit$parameters[2])
#     pvals[x>x.median] <- 1 - pvals[x>x.median]
#     pvals
#   },
#   error   = function (e) {
#     return(rep(1, length(x)))
#   }
# )
# return(x.pvals)
beta.fit <- suppressWarnings( EnvStats::ebeta(as.numeric(x), ...) )
pvals    <- pbeta(x, beta.fit$parameters[1], beta.fit$parameters[2])
pvals[x>x.median] <- 1 - pvals[x>x.median]
return(pvals)
})
return(t(chunk.filt))
}
getPValues.wbeta<- function(data.chunk, ...){
chunk.filt  <- apply(data.chunk, 1, function(x){
x.median    <- median(x, na.rm=TRUE)
x[is.na(x)] <- x.median
# # weight: bin contents
#   c           <- cut(x, c(0:100)/100)
#   b           <- table(c)
#   w           <- as.numeric(b[c])
# # weight: distance from median
#   w           <- (1 - abs(x-x.median))**3
# weight: bin contents and distance
c           <- cut(x, c(0:100)/100)
b           <- table(c)
w           <- as.numeric(b[c]) * (1 - abs(x-x.median))
beta.fit    <- suppressWarnings( ExtDist::eBeta(as.numeric(x), w, ...) )
pvals       <- pBeta(x, params=beta.fit)
pvals[x>x.median] <- 1 - pvals[x>x.median]
return(pvals)
})
return(t(chunk.filt))
}
getPValues.logn <- function(data.chunk, ...){
chunk.filt  <- apply(data.chunk, 1, function(x){
x.quantiles <- quantile(x, na.rm=TRUE)
x[is.na(x)] <- x.quantiles[3]
logn.fit    <- suppressWarnings( logitnorm::twCoefLogitnorm(x.quantiles[3], x.quantiles[4], perc=0.75, ...) )
pvals       <- plogitnorm(x, logn.fit[1], logn.fit[2])
pvals[x>x.quantiles[3]] <- 1 - pvals[x>x.quantiles[3]]
return(pvals)
})
return(t(chunk.filt))
}
#####################################################################################
registerDoParallel(cores)
cl <- makeCluster(cores)
# TODO: all multicore                 - DONE (almost)
# TODO: tile window                   -
# TODO: distributions for outliers    - DONE (beta & logitnorm, but maybe try other skew-normal such as fGarch::snormFit)
universe      <- getUniverse(data.ranges, merge.window=merge.window, min.cpgs=min.cpgs)
universe.cpgs <- unlist(universe$revmap)
betas   <- as.matrix(mcols(data.ranges)[universe.cpgs,data.samples,drop=FALSE])
if (is.null(qval.cutoff))
qval.cutoff <- pval.cutoff/nrow(betas)
# names(dimnames(betas)) <- c("cpg", "sample")
chunks <- split(1:nrow(betas), cut(1:nrow(betas),cores))
medians <- foreach (chunk=chunks, .combine=c) %dopar% matrixStats::rowMedians(betas[chunk,], na.rm=TRUE)
if (!is.null(exclude.range))
medians[medians %between% exclude.range] <- NA
if (ramr.method=="IQR") {
iqrs <- foreach (chunk=chunks, .combine=c) %dopar% matrixStats::rowIQRs(betas[chunk,], na.rm=TRUE)
betas.filtered <- (betas-medians)/iqrs
betas.filtered[abs(betas.filtered)<iqr.cutoff]  <- NA
} else if (ramr.method=="beta") {
# multi-threaded EnvStats::ebeta (speed: mme=mmue>mle>>>fitdistrplus::fitdist)
betas.filtered <- foreach (chunk=chunks) %dopar% getPValues.beta(betas[chunk,], ...)
betas.filtered <- do.call(rbind, betas.filtered)
betas.filtered[betas.filtered>=qval.cutoff] <- NA
} else if (ramr.method=="wbeta") {
betas.filtered <- foreach (chunk=chunks) %dopar% getPValues.wbeta(betas[chunk,], ...)
betas.filtered <- do.call(rbind, betas.filtered)
betas.filtered[betas.filtered>=qval.cutoff] <- NA
} else if (ramr.method=="logn") {
warning("logit-normal ramr.method doesn't work really...")
# multi-threaded logitnorm::twCoefLogitnorm
betas.filtered <- foreach (chunk=chunks) %dopar% getPValues.logn(betas[chunk,], ...)
betas.filtered <- do.call(rbind, betas.filtered)
betas.filtered[betas.filtered>=qval.cutoff] <- NA
} else {
stop("unknown 'ramr.method'")
}
getMergedRanges <- function (column) {
not.na        <- which(!is.na(betas.filtered[,column]))
ranges        <- GenomicRanges::reduce(data.ranges[universe.cpgs[not.na]], min.gapwidth=merge.window, with.revmap=TRUE)
if (length(ranges)>0) {
ranges$ncpg   <- unlist(lapply(ranges$revmap, length))
ranges$sample <- column
ranges        <- subset(ranges, ncpg>=min.cpgs & width>=max(3,min.width))
ranges$dbeta  <- sapply(ranges$revmap, function (revmap) {
mean(betas[not.na[revmap],column,drop=FALSE] - medians[not.na[revmap]])
})
if (ramr.method=="IQR") {
ranges$xiqr   <- sapply(ranges$revmap, function (revmap) {
mean(betas.filtered[not.na[revmap],column,drop=FALSE], na.rm=TRUE)
})
# } else {
#   ranges$xiqr   <- sapply(ranges$revmap, function (revmap) {
#     xiqrs <- (betas[not.na[revmap],column,drop=FALSE] - medians[not.na[revmap]]) / matrixStats::rowIQRs(betas[not.na[revmap],,drop=FALSE], na.rm=TRUE)
#     mean(xiqrs)
#   })
}
if (ramr.method=="beta") {
ranges$pval <- sapply(ranges$revmap, function (revmap) {
return( 10**mean(log10(betas.filtered[not.na[revmap],column] + .Machine$double.xmin), na.rm=TRUE) )
})
# } else {
#   ranges$pval.beta <- sapply(ranges$revmap, function (revmap) {
#     range.pvals <- getPValues.beta(betas[not.na[revmap],,drop=FALSE], ...)
#     range.pvals[range.pvals==0] <- .Machine$double.xmin
#     return( 10**mean(log10(range.pvals[,column]), na.rm=TRUE) )
#   })
}
if (ramr.method=="wbeta") {
ranges$pval <- sapply(ranges$revmap, function (revmap) {
return( 10**mean(log10(betas.filtered[not.na[revmap],column] + .Machine$double.xmin), na.rm=TRUE) )
})
# } else {
#   ranges$pval.wbeta <- sapply(ranges$revmap, function (revmap) {
#     range.pvals <- getPValues.beta(betas[not.na[revmap],,drop=FALSE], ...)
#     range.pvals[range.pvals==0] <- .Machine$double.xmin
#     return( 10**mean(log10(range.pvals[,column]), na.rm=TRUE) )
#   })
}
if (ramr.method=="logn") {
ranges$pval <- sapply(ranges$revmap, function (revmap) {
return( 10**mean(log10(betas.filtered[not.na[revmap],column] + .Machine$double.xmin), na.rm=TRUE) )
})
# } else {
#   ranges$pval.logn <- sapply(ranges$revmap, function (revmap) {
#     range.pvals <- getPValues.logn(betas[not.na[revmap],,drop=FALSE], ...)
#     range.pvals[range.pvals==0] <- .Machine$double.xmin
#     return( 10**mean(log10(range.pvals[,column]), na.rm=TRUE) )
#   })
}
ranges$revmap <- lapply(ranges$revmap, function (i) {universe.cpgs[not.na[i]]})
}
return(ranges)
}
amr.ranges <- foreach (column=colnames(betas.filtered)) %dopar% getMergedRanges(column)
stopCluster(cl)
return(unlist(as(amr.ranges, "GRangesList")))
}
getUniverse <- function (data.ranges,
merge.window=300,
min.cpgs=7)
{
if (class(data.ranges)!="GRanges")
stop("'data.ranges' must be be a GRanges object")
universe.ranges      <- reduce(data.ranges, min.gapwidth=merge.window, with.revmap=TRUE)
if (length(universe.ranges)>0) {
universe.ranges$ncpg <- unlist(lapply(universe.ranges$revmap, length))
universe.ranges      <- subset(universe.ranges, ncpg>=min.cpgs & width>2)
}
return(universe.ranges)
}
# all(?) imports
library(GenomicRanges)
library(data.table)
library(doParallel)
library(matrixStats)
library(ggplot2)
library(EnvStats)
library(ExtDist)
# library(logitnorm)
# library(sn)             # skew-normal distribution
# library(fitdistrplus)   # beta distribution
plotRAMR <- function (data.ranges,
data.samples,
ramr.ranges,
highlight=NULL,
window=300,
title=NULL)
{
ramr.ranges.reduced  <- reduce(ramr.ranges, min.gapwidth=window, with.revmap=TRUE)
ramr.ranges.relisted <- relist(ramr.ranges[unlist(ramr.ranges.reduced$revmap)], ramr.ranges.reduced$revmap)
plot.list <- list()
for (i in 1:length(ramr.ranges.relisted)) {
plot.ranges <- unlist(ramr.ranges.relisted[i])
revmap.rows <- unique(unlist(plot.ranges$revmap))
data.hits   <- unique(queryHits(findOverlaps(data.ranges, plot.ranges, maxgap=window, ignore.strand=TRUE)))
if (length(data.hits)>0) {
plot.data   <- data.frame(data.ranges[data.hits, data.samples], check.names=FALSE, stringsAsFactors=FALSE)
colnames(plot.data) <- c(colnames(plot.data)[1:5], data.samples)
plot.data$median <- matrixStats::rowMedians(as.matrix(plot.data[,data.samples]), na.rm=TRUE)
if (is.null(title))
title <- as.character(reduce(plot.ranges))
if (is.null(highlight))
highlight <- unique(plot.ranges$sample)
colorify       <- c("median",highlight)
plot.data.melt <- melt(plot.data, id.vars=c("seqnames","start","end","width","strand"),
variable.name="sample", value.name="beta")
plot.data.melt <- cbind(plot.data.melt, list(alpha=0.5,color=factor("lightgrey",levels=c("lightgrey",colorify))))
plot.data.melt[plot.data.melt$sample %in% colorify, "alpha"] <- 0.9
for (sample.name in colorify)
plot.data.melt[plot.data.melt$sample==sample.name,"color"] <- sample.name
gene.plot <- ggplot(plot.data.melt, aes_string(x="start", y="beta", group="sample", color="color", alpha="alpha")) +
geom_line(size=0.5) +
geom_point(size=1) +
scale_x_continuous(name="position") +
scale_y_continuous(name="beta value", limits=c(-0, 1), breaks=c(0, 0.25, 0.5, 0.75, 1)) +
scale_color_discrete(name="samples", limits=colorify) +
scale_alpha_continuous(guide="none") +
theme(legend.text=element_text(size=8), #legend.position="none", legend.title=element_blank(),
axis.text.x=element_text(size=8, angle=0), #, color=.data.cpgs.colors),
axis.text.y=element_text(size=8)) +
ggtitle(title)
# print(gene.plot)
plot.list[length(plot.list)+1] <- list(gene.plot)
}
}
return(plot.list)
}
# plotRAMR <- function (data.ranges,
#                       data.samples,
#                       ramr.ranges,
#                       window=300,
#                       title=NULL)
# {
#   ramr.ranges.reduced  <- reduce(ramr.ranges, with.revmap=TRUE)
#   ramr.ranges.relisted <- relist(ramr.ranges[unlist(ramr.ranges.reduced$revmap)], ramr.ranges.reduced$revmap)
#
#   for (i in 1:length(ramr.ranges.relisted)) {
#     plot.ranges <- unlist(ramr.ranges.relisted[i])
#     revmap.rows <- unique(unlist(plot.ranges$revmap))
#     data.hits   <- unique(queryHits(findOverlaps(data.ranges, plot.ranges, maxgap=window, ignore.strand=TRUE)))
#     plot.data   <- data.frame(data.ranges[data.hits, data.samples], check.names=FALSE, stringsAsFactors=FALSE)
#     colnames(plot.data) <- c(colnames(plot.data)[1:5], data.samples)
#     plot.data$median <- matrixStats::rowMedians(as.matrix(plot.data[,data.samples]), na.rm=TRUE)
#
#     colorify       <- c("median",unique(plot.ranges$sample))
#     plot.data.melt <- melt(plot.data, id.vars=c("seqnames","start","end","width","strand"),
#                            variable.name="sample", value.name="beta")
#     plot.data.melt <- cbind(plot.data.melt, list(alpha=0.5,color=factor("lightgrey",levels=c("lightgrey",colorify))))
#
#     plot.data.melt[plot.data.melt$sample %in% colorify, "alpha"] <- 0.9
#     for (sample.name in colorify)
#       plot.data.melt[plot.data.melt$sample==sample.name,"color"] <- sample.name
#
#     gene.plot <- ggplot(plot.data.melt, aes(x=start, y=beta, group=sample, color=color, alpha=alpha)) +
#       geom_line(size=0.5) +
#       geom_point(size=1) +
#       # scale_x_discrete(limits=revmap.rows) +
#       scale_x_continuous(name="position") +
#       scale_y_continuous(name="beta value", limits=c(-0, 1), breaks=c(0, 0.25, 0.5, 0.75, 1)) +
#       scale_color_discrete(name="samples", limits=colorify) +
#       scale_alpha_continuous(guide="none") +
#       theme(legend.text=element_text(size=8), #legend.position="none", legend.title=element_blank(),
#             axis.text.x=element_text(size=8, angle=0), #, color=.data.cpgs.colors),
#             axis.text.y=element_text(size=8)) +
#       ggtitle( ifelse( !is.null(title), title, as.character(reduce(plot.ranges)) ) )
#
#     print(gene.plot)
#   }
# }
library(GenomicRanges)
library(data.table)
library(doParallel)
library(matrixStats)
library(ggplot2)
library(gridExtra)
library(EnvStats)
library(logitnorm)
# load
project  <- "GSE51032"
proj.dir <- paste0("/Home/siv22/oni062/work/scripts/ramr/data/", project, "/")
load(paste0(proj.dir, project, ".data.Rdata"))
load("/Home/siv22/oni062/work/scripts/tcga/data/tempfiles/to.remove.RData")
# clean
geo.ranges <- geo.ranges[!(names(geo.ranges) %in% to.remove)]
geo.ranges <- geo.ranges[!(seqnames(geo.ranges) %in% c("chrX","chrY"))]
# process, but don't forget to copy-paste functions first...
system.time(ramr <- getRAMR(geo.ranges, sample.ids, ramr.method="beta", qval.cutoff=1e-3, min.cpgs=7, merge.window=1000)) # in principle, wbeta at 1e-5 gives appropriate results
ramr <- ramr[order(ramr$pval)]
ramr
sort(table(ramr$sample))
do.call("grid.arrange", c(plotRAMR(geo.ranges, sample.ids, ramr[1:6]), ncol=2))
# info table
library(stringr)
library(dplyr)
info.list  <- lapply(sample.info, function(x){
match.table <- str_match(x$characteristics_ch1, pattern="(.*?): (.*)")
result <- match.table[,3]
names(result) <- match.table[,2]
return(result)
})
info.table <- data.frame(do.call(bind_rows, info.list), row.names=names(info.list), stringsAsFactors=FALSE, check.names=FALSE)
info.table$age <- as.numeric(as.character(info.table$age))
info.table <- cbind( info.table, nramr=as.numeric(table(ramr$sample)[rownames(info.table)]) )
info.table[is.na(info.table$nramr), "nramr"] <- 0
info.table$hasramr <- as.factor(info.table$nramr>0)
info.table$cancer  <- as.factor(!is.na(info.table$`cancer type (icd-10)`))
info.table$ctype   <- as.factor(sapply(info.table$`cancer type (icd-10)`, function (icd10) {
case_when(
grepl("C[12].", icd10) ~ "colorectal",
icd10 == "C50"         ~ "breast",
is.na(icd10)           ~ NA_character_,
TRUE                   ~ "other"
)
}))
# gene names
load("/Home/siv22/oni062/work/scripts/ramr/data/GRCh37.p13.2019.12.12.Rdata")
system.time(ramr$genes <- sapply(split(ramr,1:length(ramr)),
function(x){ suppressWarnings( paste0( unique(grch37.ranges[queryHits(findOverlaps(grch37.ranges,x,maxgap=5000,ignore.strand=TRUE))]$`Gene name`) ,collapse=", ") ) }))
info.table[ramr[ramr$genes=="RALGAPA2"]$sample,]
plotRAMR(geo.ranges, sample.ids, ramr[ramr$genes=="RALGAPA2"])
info.table[ramr[grep("CHFR",ramr$genes)]$sample,]
plotRAMR(geo.ranges, sample.ids, ramr[grep("CHFR",ramr$genes)])
info.table[ramr[grep("BRCA1",ramr$genes)]$sample,]
plotRAMR(geo.ranges, sample.ids, ramr[grep("BRCA1",ramr$genes)][1])
plotRAMR(geo.ranges, sample.ids, grch37.ranges[grep("MGMT",grch37.ranges$`Gene name`)])
plotRAMR(geo.ranges, sample.ids, grch37.ranges[grep("MSH2",grch37.ranges$`Gene name`)])
plotRAMR(geo.ranges, sample.ids, grch37.ranges[grep("MSH6",grch37.ranges$`Gene name`)])
##### GSE51032 specific stuff:
## More up, but those are CpG-islands, not surprising
# up versus down
length(ramr[ramr$dbeta>0])
length(ramr[ramr$dbeta<0])
# low/high assuming normal distribution
library(car)
qqPlot(table(ramr$sample))
table.q3  <- quantile(info.table$nramr)[4]
table.iqr <- IQR(table(ramr$sample))
highRAMRcases <- rownames(info.table)[which(info.table$nramr > table.q3+1.5*table.iqr)]
lowRAMRcases  <- setdiff(sample.ids,highRAMRcases)
info.table[highRAMRcases,]
ramr[ramr$sample %in% lowRAMRcases]
ramr[grep("MLH1",ramr$genes)]
ramr[grep("MLH1",ramr$genes)]$sample
s.mlh <- ramr[grep("MLH1",ramr$genes)]$sample
ramr[grep("CHFR",ramr$genes)]$sample
s.chfr <- ramr[grep("CHFR",ramr$genes)]$sample
ramr[grep("HSPA1L",ramr$genes)]$sample
ramr[grep("HSPA1L",ramr$genes)]
s.hspal <- ramr[grep("HSPA1L",ramr$genes)]$sample
ramr[grep("LINC00662",ramr$genes)]
ramr[grep("LINC00662",ramr$genes)]$sample
s.linc -> ramr[grep("LINC00662",ramr$genes)]$sample
s.linc <- ramr[grep("LINC00662",ramr$genes)]$sample
s.mlh1
s.mlh
s.chfr
sort(s.mlh)
sort(s.chfr)
sort(s.hspal)
sort(s.linc)
length(c(s.mlh,s.chfr,s.hspal,s.linc))
length(unique(c(s.mlh,s.chfr,s.hspal,s.linc)))
length(highRAMRcases)
intersect(c(s.mlh,s.chfr,s.hspal,s.linc), highRAMRcases)
s.mlh <- intersect(lowRAMRcases, ramr[grep("MLH1",ramr$genes)]$sample)
s.chfr <- intersect(lowRAMRcases, ramr[grep("CHFR",ramr$genes)]$sample)
s.hspal <- intersect(lowRAMRcases, ramr[grep("HSPA1L",ramr$genes)]$sample)
s.linc <- intersect(lowRAMRcases, ramr[grep("LINC00662",ramr$genes)]$sample)
length(c(s.mlh,s.chfr,s.hspal,s.linc))
length(unique(c(s.mlh,s.chfr,s.hspal,s.linc)))
load("/Home/siv22/oni062/work/scripts/ramr/data/GSE51032/tcga.coad.Rdata")
tcga.coad.ramr.hg19.selected <- tcga.coad.ramr.hg19[abs(tcga.coad.ramr.hg19$dbeta.tum - tcga.coad.ramr.hg19$dbeta.adj) > 0.2 &
tcga.coad.ramr.hg19$dbeta.tum / tcga.coad.ramr.hg19$dbeta.adj  > 1    ]
tcga.coad.ramr.hg19.selected
s.mlh.tcga <- tcga.coad.ramr.hg19.selected[grep("MLH1",tcga.coad.ramr.hg19.selected$genes)]$sample
s.mlh.tcga
tcga.coad.ramr.hg19.selected[grep("HSPA1L",tcga.coad.ramr.hg19.selected$genes)]$sample
tcga.coad.ramr.hg19.selected[grep("CHFR",tcga.coad.ramr.hg19.selected$genes)]$sample
tcga.coad.ramr.hg19.selected[grep("LINC00662",tcga.coad.ramr.hg19.selected$genes)]$sample
tcga.coad.ramr.hg19.selected[grep("CHFR",tcga.coad.ramr.hg19.selected$genes)]
?importFrom
?stats::dbeta
?sd
?mean
?median
?var
?cov2cor
?coef
?plot
